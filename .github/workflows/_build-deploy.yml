# Reusable workflow for building and deploying
# Called by deploy-qa.yml and deploy-prod.yml

name: Build & Deploy

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment (qa or production)'
        type: string
        required: true
      service_name:
        description: 'Cloud Run service name'
        type: string
        required: true
      site_url:
        description: 'Site URL for the environment'
        type: string
        required: true
      runner:
        description: 'Runner to use'
        type: string
        default: 'ubuntu-latest'
      image_tag:
        description: 'Docker image tag (defaults to commit SHA)'
        type: string
        default: ''
    secrets:
      GCP_SA_KEY:
        required: true
      GCP_PROJECT_ID:
        required: true
      SECRETS_PROJECT_ID:
        required: true
      FIREBASE_PROJECT_ID:
        required: true

env:
  NODE_VERSION: 20
  GAR_LOCATION: us-central1
  GAR_REPO: web-apps

jobs:
  build:
    name: Build Docker Image
    runs-on: ${{ inputs.runner }}
    outputs:
      image_uri: ${{ steps.meta.outputs.image_uri }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      
      - uses: google-github-actions/setup-gcloud@v2
      
      - run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev --quiet
      
      - name: Compute metadata
        id: meta
        shell: bash
        run: |
          TAG="${{ inputs.image_tag }}"
          [ -z "$TAG" ] && TAG="${GITHUB_SHA::7}"
          
          IMAGE_URI="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.GAR_REPO }}/gsdta-web:${{ inputs.environment }}-${TAG}"
          
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "üì¶ Image: $IMAGE_URI"
      
      - name: Fetch Firebase secrets
        id: secrets
        run: |
          # Secrets are stored in their respective project (prod secrets in prod, QA secrets in QA)
          echo "api_key=$(gcloud secrets versions access latest --secret=FIREBASE_API_KEY --project=${{ secrets.SECRETS_PROJECT_ID }})" >> $GITHUB_OUTPUT
          echo "auth_domain=$(gcloud secrets versions access latest --secret=FIREBASE_AUTH_DOMAIN --project=${{ secrets.SECRETS_PROJECT_ID }})" >> $GITHUB_OUTPUT
          echo "project_id=$(gcloud secrets versions access latest --secret=FIREBASE_PROJECT_ID --project=${{ secrets.SECRETS_PROJECT_ID }})" >> $GITHUB_OUTPUT
          echo "app_id=$(gcloud secrets versions access latest --secret=FIREBASE_APP_ID --project=${{ secrets.SECRETS_PROJECT_ID }})" >> $GITHUB_OUTPUT
      
      - uses: docker/setup-buildx-action@v3
      
      - uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.image_uri }}
          no-cache: true
          build-args: |
            VERSION=${{ steps.meta.outputs.tag }}
            COMMIT=${{ github.sha }}
            NEXT_PUBLIC_AUTH_MODE=firebase
            NEXT_PUBLIC_API_BASE_URL=/api
            NEXT_PUBLIC_USE_MSW=false
            NEXT_PUBLIC_SITE_URL=${{ inputs.site_url }}
            NEXT_PUBLIC_FIREBASE_API_KEY=${{ steps.secrets.outputs.api_key }}
            NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=${{ steps.secrets.outputs.auth_domain }}
            NEXT_PUBLIC_FIREBASE_PROJECT_ID=${{ steps.secrets.outputs.project_id }}
            NEXT_PUBLIC_FIREBASE_APP_ID=${{ steps.secrets.outputs.app_id }}

  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    needs: [build]
    environment: ${{ inputs.environment }}
    steps:
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      
      - uses: google-github-actions/setup-gcloud@v2
      
      - name: Deploy to Cloud Run
        run: |
          echo "üöÄ Deploying to ${{ inputs.environment }}"
          echo "   Service: ${{ inputs.service_name }}"
          echo "   Image: ${{ needs.build.outputs.image_uri }}"
          echo "   URL: ${{ inputs.site_url }}"
          
          # Clear any existing secret bindings that conflict with env vars
          # This handles the transition from secrets to env vars
          gcloud run services update ${{ inputs.service_name }} \
            --region ${{ env.GAR_LOCATION }} \
            --remove-secrets "FIREBASE_PROJECT_ID" \
            --quiet 2>/dev/null || true
          
          # Note: Firebase secrets are baked into the Docker image at build time
          # We only need FIREBASE_PROJECT_ID as runtime env var for the API server
          gcloud run deploy ${{ inputs.service_name }} \
            --image ${{ needs.build.outputs.image_uri }} \
            --region ${{ env.GAR_LOCATION }} \
            --platform managed \
            --allow-unauthenticated \
            --port 3000 \
            --set-env-vars "NEXT_TELEMETRY_DISABLED=1,NODE_ENV=production,NEXT_PUBLIC_API_BASE_URL=/api,GOOGLE_CLOUD_PROJECT=${{ secrets.FIREBASE_PROJECT_ID }},FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }},NEXT_PUBLIC_AUTH_MODE=firebase,NEXT_PUBLIC_USE_MSW=false,NEXT_PUBLIC_SITE_URL=${{ inputs.site_url }}"
      
      - name: Health check
        run: |
          URL="${{ inputs.site_url }}"
          echo "‚è≥ Waiting for deployment..."
          sleep 15
          
          echo "üîç Health check: $URL/api/v1/health"
          curl -f $URL/api/v1/health
          
          echo ""
          echo "‚úÖ Deployed successfully!"
          echo "üåê URL: $URL"
